# 设计模式
## 单例模式
### 饿汉式单例模式
还没有获取实例对象，实例对象就产生了。
一定是线程安全。
```
class Singleton {
public:
    static Singleton* getInstance() //3. 获取类的唯一实例对象的接口方法
    {
        return &instance;
    }
private:
    static Singleton instance; // 2.定义一个类的实例对象
    Singleton() //1.构造函数私有化
    { 

    }
}
Singleton Singleton::instance; // 4.在类的外部初始化实例对象
```
### 懒汉式单例模式
直到第一次获取的时候才创建实例对象
```
class Singleton {
public:
    static Singleton* getInstance() //3. 获取类的唯一实例对象的接口方法
    {
        if(instance == nullptr)
        {
            instance = new Singleton();
        }
        return instance;
    }
private:
    static Singleton *instance; // 2.定义一个类的实例对象
    Singleton() //1.构造函数私有化
    { 

    }
}
Singleton Singleton::instance = nullptr; // 4.在类的外部初始化实例对象
```
上述实现的懒汉式并非线程安全，在多线程环境下可能会创建多个实例对象。
第一种实现方式：
为了确保线程安全，需要在获取实例对象的方法中添加锁机制。
```
std::mutex mtx; // 定义一个互斥锁
class Singleton {
public:
    static Singleton* getInstance() //3. 获取类的唯一实例对象的接口方法
    {
        if(instance == nullptr)
        {
            lock_guard<mutex> lock(mtx); // 加锁,锁加双重判断
            if(instance == nullptr) // 再次检查实例是否为空
            {
                instance = new Singleton();
            }
        }
        //自动解锁
        return instance;
    }
private:
    static Singleton *volatile instance; // 2.定义一个类的实例对象，
    //其中volatile关键字确保多线程环境下的可见性，每次都从内存读取 - 防止编译器将变量值缓存在寄存器中
    Singleton() //1.构造函数私有化
    { 

    }
}
Singleton* volatile Singleton::instance = nullptr; // 4.在类的外部初始化实例对象
```
第二种实现方式：
```
class Singleton {
public:
    static Singleton& getInstance() //3. 获取类的唯一实例对象的接口方法
    {
        static Singleton instance; // 2.定义一个类的实例对象
        return instance;   
    }
private:
    Singleton() //1.构造函数私有化
    { 

    }
}
```
更加推荐第二种实现方式，因为它是线程安全的且不需要添加锁机制。
## 工厂模式
### 简单工厂模式
把对象的创建封装在一个接口函数中，根据不同的传入标识，返回不同的对象实例。不需要客户自己new对象，不用了解对象的创建过程。

缺点：提供创建对象的接口函数不闭合，不能对修改关闭。
```
class Product {
public:
    virtual void show() = 0;
};
class ConcreteProductA : public Product {
public:
    void show() override {
        cout << "ConcreteProductA" << endl;
    }
};
class ConcreteProductB : public Product {
public:
    void show() override {
        cout << "ConcreteProductB" << endl;
    }
};
class Factory {
public:
    static Product* createProduct(string type) {
        if(type == "A") {
            return new ConcreteProductA();
        } else if(type == "B") {
            return new ConcreteProductB();
        } else {
            return nullptr;
        }
    }
};
int main() {
    unique_ptr<Product> productA = unique_ptr<Product>(Factory::createProduct("A"));
    productA->show();
    unique_ptr<Product> productB = unique_ptr<Product>(Factory::createProduct("B"));
    productB->show();
    return 0;
}
```
### 工厂方法模式
Factory基类定义了一个纯虚函数（产品），定义派生类（具体工厂）负责创建对应的产品。可以做到不同的产品在不同的工厂创建，能够对现有
的产品进行扩展，而不需要修改工厂的代码。
缺点：实际上很多产品是有关系的，属于一类，不应该放到不同的工厂中创建。这样会不符合实际的产品创建且会导致工厂类很多，不好管理。

```
class Product {
public:
    virtual void show() = 0;
};
class ConcreteProductA : public Product {
public:
    void show() override {
        cout << "ConcreteProductA" << endl;
    }
};
class ConcreteProductB : public Product {
public:
    void show() override {
        cout << "ConcreteProductB" << endl;
    }
};
class Factory {
public:
    virtual Product* createProduct() = 0;
};
class ConcreteFactoryA : public Factory {
public:
    Product* createProduct() override {
        return new ConcreteProductA();
    }
};
class ConcreteFactoryB : public Factory {
public:
    Product* createProduct() override {
        return new ConcreteProductB();
    }
};
```
### 抽象工厂模式
把有关联关系的产品的接口函数放到一个抽象工厂里面，派生类（具体工厂）应该负责创建该系列的全部产品。
```
class AbstractFactory {
public:
    virtual Product* createProduct() = 0;
};
class ConcreteFactoryA : public AbstractFactory {
public:
    Product* createProduct() override {
        return new ConcreteProductA();
    }
};
class ConcreteFactoryB : public AbstractFactory {
public:
    Product* createProduct() override {
        return new ConcreteProductB();
    }
};
```

